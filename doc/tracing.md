# Distributed Tracing on the DSH platform

The DSH distributed tracing infrastructure is based on
[Jaeger](http://jaegertracing.io/), an open source distributed tracing
framework that follows the [OpenTracing](http://opentracing.io/) standard.

## What is a distributed trace?

A **trace** represents the conceptual path a message takes as it travels
through a distributed system. It captures all operations performed on a
message, and on all messages that are emitted as a result of these operations.
For each of the steps in the journey, the trace records
- start and end time
- (optionally) a set of tags that identify the message flow
- (optionally) a set of logs that mark events of note that happened at
  particular times during the processing of the message.

A trace is really a collection of **spans**, where each span captures all
details about a single step in processing the message. Spans within a trace
have a causal relationship with one another. In effect, a trace could be
defined as a maximal set of spans that have a causal relationship. Two kinds
of relationships are typically distinguished:

- **child-of** relationships indicate that the action in the parent span
  relies on the result of the action in the child span. For example, a span
  representing the action of "processing a message" may have child spans that
  represent "parsing the message", "validating the message" and "storing the
  message".
- **follows-from** relationships indicate that the action in the parent span
  is not reliant on the result of the action in the child span. For example,
  when a message is forwarded to another component for further processing, the
  spans generated by the next component in the chain have a follows-from
  relationship with the spans generated by the forwarding component.

In order for the relationships between spans to be built across components in
a distributed system, there must be a way to have some identifying
characteristic of a span or trace travel along with the message through the
system. This identifying characteristic is called a **span context**. Span
context are either passed in-band (as part of the overall message) or
out-of-band in the form of message metadata (e.g. as a set of HTTP request
and/or response headers for a REST call).

For an in-depth discussion of the above concepts, please refer to the
[OpenTracing
specification](https://github.com/opentracing/specification/blob/master/specification.md).

## Practical steps to enable tracing in your application

### Library

Use the latest version of the Jaeger client libraries for your programming
language of choice. Jaeger client libraries are available for Java, Go,
Python, Node.js and C++.

In addition, you will likely also need to install the corresponding
OpenTracing library.

### Configuration

The following configuration settings **MUST** be honored to work with the
DSH tracing infrastructure:

- configure the Jaeger reporter to use a HTTP sender instead of the default
  UDP sender.
- the *reporting endpoint* must be acquired from the `DSH_TRACING_ENDPOINT`
  environment variable that is automatically provisioned when an application
  container starts up.
- the *service name* must be `<tenant-id>.<application-name>`, analogous to the
  Marathon/AMP app name. For example, if the Marathon application identifier
  for your application is `/foo/bar-app`, the service name must be
  `foo.bar-app`.

In addition to the mandatory configuration settings described above, you can
also configure the *sampling strategy* for the tracer. Jaeger supports the
following sampling strategies:

- **constant** sampling samples either all or none of the generated traces.
- **probabilistic** samples traces with a configurable probability
- **rate limiting** samples traces at a fixed rate, for example 2 traces per
  second.
- **remote** leaves it up to the trace collection agent to decide on the
  sampling strategy at run time. **This option is currently not supported on
  the DSH platform.**

For some guidance on the appropriate sampling strategy for various use cases,
check the [Best Practices](#best-practices) section of this document.

### Passing span contexts through the processing chain

As mentioned earlier, span contexts must be passed between different
components for them to be able to contribute spans to the same trace. As the
main message exchange mechanism on the DSH platform is Kafka, there is no such
thing as a "message header" (as would be the case in HTTP requests), where the
the span context can be included for propagation.

Instead, the message payload on all public streams (and at your discretion
also on non-public streams) is wrapped in a data envelope. The span context is
injected as a text map in the `tracing` field of the [data
envelope](envelopes.md).

Therefore, on an incoming message, one should always check the data envelope
to see if there is a span context attached to the message. Likewise, one
should not forget to inject span contexts in outgoing messages.

## Inspecting recorded traces

The facilities for live inspection of collected traces are still under
development.  Please use the helpdesk ticketing system to request access to
tracing information as a short term workaround.

## Best practices

### Set the Java address resolution cache lifetime at startup

The Java Virtual Machine caches DNS name lookups. Under some circumstances
(for example, when a Security Manager is present), this caching is indefinite.
Because IP addresses may change on a regular basis in a cloud environment,
it is necessary to restrict the maximum TTL for the name cache. **This must be
done prior to the first networking call made by your application.**

There are two approaches to setting the name cache TTL:

- set the `networkaddress.cache.ttl` property in the
  `$JAVA_HOME/jre/lib/security/java.security` file
- programmatically set the TTL in your `main` function:
  ```java
  java.security.Security.setProperty("networkaddress.cache.ttl", "60")
  ```

The recommended TTL setting is 60 seconds or less.

### Be resilient to tracing agent outages

The Jaeger client libraries have the unfortunate habit of throwing exceptions
when the tracing endpoint host name cannot be resolved at initialization time.
That means your application may fail to start if there is a temporary tracing
agent outage.

The best course of action is to treat a failed initialization of the tracing
libraries as a retryable, non-critical error:

- emit a warning in the application logs about the application failure
- create an OpenTracing NOOP tracer (a stub tracer offered by the OpenTracing
  APIs in any language) to replace the Jaeger tracer for the time being so
  that you don't have to write all your code to deal with the absence of the
  tracer object.
- periodically retry the tracer creation until you succeed in setting up the
  actual Jaeger tracer.

### Mark data ingress and egress points with the appropriate tags

The DSH platform runs a daily monitoring job that inspects all traces to
compute end-to-end latencies for all data flows that pass through the system.
To enable this, the platform has to be able to identify all data ingress and
egress points (i.e. all places where data enters or leaves the platform).

DSH identifies ingress and egress points based on dedicated tags added to the
corresponding spans:
- `dsh-source=<sourceid>` marks an ingress point
- `dsh-sink=<sinkid>` marks an egress point

The `sourceid` and `sinkid` values are free-form, but should be constant for a
given ingress/egress point, and it should be reasonably descriptive. For
example, the MQTT egress points (where messages are sent to client devices)
have sink ID `mqtt.liveforward` (for live messages forwarded to subscribers)
and `mqtt.retainedforward` (for retained messages forwarded to subscribers).

### Include a `tt-use-case` tag in all spans for TalkingTraffic

To better enable debugging and reporting in the TalkingTraffic project, it is
recommended to add a `tt-use-case` tag with the use case number as value in
all message flows.

### Sampling frequency

In high-volume messaging scenarios, it does not make sense to trace every
individual message. Therefore, the Jaeger tracing framework includes a
sampling feature that selects (based on [configuration](#configuration))
whether a specific message will be traced.

Note that sampling is applied only at the origin of a trace: any spans that
are created as references (`child-of` or `follows-from`) from another span
just take over the sampling decision that was made by the original span.
Therefore, an application that is never at the origin of a message flow (e.g.
a processing application that only takes in messages, performs a computation
and then emits a result message) never actually takes any sampling decisions.

The generally recommended sampling rate for message flows is 1Hz. This is most
easily achieved with the `rate limiting` sampler configuration.

### Be selective when injecting span contexts in high-volume message flows

Even if a trace is not sampled, the spans still have a span context that can
be injected in outgoing messages for other tracers to follow up from. In very
high-throughput message flows, the impact of span context injection is
noticeable in the CPU usage (and thus throughput) of the application.

If that is the case for your application, consider only injecting span
contexts in outgoing messages if they are indeed sampled. In the Java client
library, for example, one can look at `span.context().isSampled()` to figure
out whether a span is effectively sampled.

### Always pass on span contexts, even if your application doesn't do any tracing

The coherence of distributed tracing information hinges on the correct passing
of span contexts across the various distributed system components that act
upon a message flow. Therefore, even if your application does not explicitly
add information to a trace, it should still at least pass on any embedded span
contexts from incoming messages to related outgoing messages. That way,
downstream components can still contribute to the trace, even if there is a
"hole" in the trace where the information about your component should have
appeared.
